rules = [
  DisableSyntax,
  Disable,
  LeakingImplicitClassVal,
  NoValInForComprehension,
  ProcedureSyntax,
  RedundantSyntax,
  ExplicitResultTypes,
  TypelevelUnusedIO,
  TypelevelMapSequence,
  TypelevelAs,
  TypelevelUnusedShowInterpolator,
  TypelevelIORandomUUID
]
triggered.rules = [
  DisableSyntax,
  Disable,
  LeakingImplicitClassVal,
  NoValInForComprehension,
  ProcedureSyntax,
  RedundantSyntax,
]

DisableSyntax.noVars = true
DisableSyntax.noThrows = true
DisableSyntax.noNulls = true
DisableSyntax.noReturns = true
DisableSyntax.noWhileLoops = true
DisableSyntax.noAsInstanceOf = true
DisableSyntax.noIsInstanceOf = true
DisableSyntax.noXml = true
DisableSyntax.noDefaultArgs = false
DisableSyntax.noFinalVal = true
DisableSyntax.noFinalize = true
DisableSyntax.noValPatterns = true
DisableSyntax.noSemicolons = true
DisableSyntax.noValInAbstract = true
DisableSyntax.noImplicitObject = true
DisableSyntax.keywords = [
  this,
  do,
  super,
  try,
  catch,
  abstract
]

ExplicitResultTypes.memberVisibility = [
  Public,
  Protected,
  Private
]
ExplicitResultTypes.fatalWarnings = true

Disable.symbols = [
  {
    symbol = "scala.Option.get"
    id = "Option.get"
    message =
      """|Option.get is the root of all evils
         |
         |If you want Option.get, you should use match case Some/None"""
  }
  {
    symbol = "scala.collection.IterableOps.head"
    id = "iterable.head"
    message = "Instead of head use headOption or match case head :: tail => ???"
  }
  {
    symbol = "scala.collection.IterableOps.last"
    id = "iterable.last"
    message = "Instead of last use lastOption"
  }
  {
    symbol = "scala.collection.immutable.List.last"
    id = "List.last"
    message = "Instead of List.last use List.lastOption"
  }
  {
    symbol = "scala.collection.mutable"
    id = "collection.mutable"
    message = "Instead of collection.mutable use collection.immutable"
  }
  {
    symbol = "scala.collection.StrictOptimizedSeqOps.appended"
    id = "Seq.appended"
    message =
      """Appended (O(n)) is not optimized for List, use prepended (O(1) instead"""
  }
  {
    symbol = "scala.collection.immutable.List.max"
    id = "List.max"
    message = "Instead of List.max use List.maxOption"
  }
  {
    symbol = "scala.collection.immutable.List.maxBy"
    id = "List.maxBy"
    message = "Instead of List.maxBy use List.maxByOption"
  }
  {
    symbol = "scala.collection.immutable.List.min"
    id = "List.min"
    message = "Instead of List.min use List.minOption"
  }
  {
    symbol = "scala.collection.immutable.List.minBy"
    id = "List.minBy"
    message = "Instead of List.minBy use List.minByOption"
  }
  {
    symbol = "scala.collection.immutable.List.foldRight"
    id = "List.foldRight"
    message = "Instead of List.foldRight use List.foldLeft"
  }
  {
    symbol = "scala.collection.immutable.List.toSeq"
    id = "List.toSeq"
    message = "Instead of List.toSeq use List themself"
  }
  {
    symbol = "scala.collection.immutable.List.reduce"
    id = "List.reduce"
    message = "Instead of List.reduce use List.reduceOption"
  }
  {
    symbol = "scala.collection.immutable.List.apply"
    id = "List.apply"
    message = "Don't get elements by index"
  }
  {
    symbol = "scala.collection.immutable.Seq.apply"
    id = "Seq"
    message = "Instead of Seq use List"
  }
  "java.lang.System"
  "scala.Predef.assert"
  "scala.Predef.assume"
  "scala.Predef.require"
  "scala.collection.immutable.List.foreach"
  "scala.collection.LinearSeq.foreach"
]
