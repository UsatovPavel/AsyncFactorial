# HTTP-сервер

- Запуск: `HttpTask` (IOApp), поднимает tapir + vertx сервер `0.0.0.0:8080`.
- Endpoint: `POST /factorial`
    - Headers: опционально `X-Job-Id` (если нет, генерируется).
    - Body: JSON массив `Int`.
    - Response: JSON массив объектов `{jobId,itemId,input,result?,error?}`; порядок не гарантирован.
    - Инвариант: у каждого элемента ровно одно из `result`/`error`.
- Swagger UI: `http://127.0.0.1:8080/docs`
- Конфигурация: `application.conf` (section `server`)
    - `host` (default `0.0.0.0`)
    - `port` (default `8080`)
    - `parallelism` (default 0 → `availableProcessors`)
- Параллельность:

# Консольное приложение

Консольное приложение: Task (IOApp) → TaskProducer (spawn workers) → FactorialAccumulator → Queue → NumberWriter →
out.txt
Папка semaphore в src/... и test/... не относится к рабочим файлам.

На вход из консоли подается список чисел для которых нужно рассчитать факториал, необходимо
вычислить значение после чего сохранить результат в конец файла out.txt. Ввод пользователя должен быть не
блокирующим (параллельное исполнение задний на вычисление факториала). Ввод пользователя - каждое число с новой
строки, ввод считать законченным после ввода exit; после ввода exit нужно либо дождаться выполнения всех заданий,
либо отменить все не завершённые задания.
Разрешено писать в файл не в том порядке в которым задания были даны

## Требования

* Какие библиотеки я могу использовать? - все кроме тех что указаны в чёрном списке (black list: `akka`, `play`,
  `monix`)
* Какие библиотеки посоветуете? - `cats-effect 3` или `ZIO 2` (для runtime); `sttp.client4` (для http client); `fs2`
  (для kafka и streams); `tapir` (для http server); `circe` или `tethys` (для json); `doobie` (для db); `scalatest`(
  +cats-effect) или  `weaver` (для тестов);

## Code Style:

* Переменные и функции должны иметь осмысленные названия;
* Тест классы именуются `<ClassName>Spec`, где `<ClassName>` - класс к которому пишутся тесты;
* Тест классы находятся в том же пакете, что и класс к которому пишутся тесты (например, класс `Fibonacci` находится в
  пакете `fibonacci` в директории `src/main/scala/fibonacci`, значит его тест класс `FibonacciSpec` должен быть в том же
  пакете в директории `src/test/scala/fibonacci`);
* Каждый тест должен быть в отдельном test suite;
* Использовать java коллекции запрещается (используйте `Scala` коллекции);
* Использовать scala `mutable` коллекции запрещается (используйте `immutable` коллекции);
* Использовать `var` запрещается (используйте `val`);
* Использование `this` запрещается (используйте `self`, если надо);
* Использование `throw` запрещается (используйте `Either` или `Option`);
* Использование `try` запрещается (используйте `Either` или `ApplicativeError`);
* Использование `null` запрещается (используйте `Option`);
* Использование `return` запрещается;
* Использование `System.exit` запрещается;
* Касты или проверки на типы с помощью методов из Java вроде `asInstanceOf` запрещаются;
* Использование циклов запрещается (используйте `for comprehension`, `tailRec`; или методы `Monad`: `iterateWhile`,
  `foreverM` и др.; или методы коллекций `fold`/`foldLeft`/ `reduce`/ `map`/ `filter`);
* Использование `foreach` (аналогично предыдущему пункту);
* Использование небезопасных вызовов разрешено только в тестах (например: `.get` у `Option`, `.head`, обращение по
  индексу);
* Использование взятия и освобождения примитивов синхронизации: `semaphore`, `mutex` - из разных потоков запрещено;
* Использование `require` / `assert` для ошибок запрещается (используйте `shouldBe` из scalatest и его вариации);
* Использование аннотаций запрещается (кроме `@tailrec`);
